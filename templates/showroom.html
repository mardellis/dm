<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sanal Showroom - CyberDesign</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .controls-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 15px;
            color: #fff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            pointer-events: auto;
        }

        .controls-info h3 {
            color: #00ffff;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .controls-info p {
            margin: 0.5rem 0;
            font-size: 0.9rem;
            color: #ccc;
        }

        .controls-info kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.3rem 0.6rem;
            border-radius: 5px;
            font-family: monospace;
            color: #00ffff;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 15px;
            color: #fff;
            border: 1px solid rgba(255, 0, 255, 0.3);
            max-width: 400px;
            pointer-events: auto;
        }

        .info-panel h3 {
            color: #ff00ff;
            margin-bottom: 0.5rem;
        }

        .info-panel p {
            color: #ccc;
            line-height: 1.6;
        }

        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 2px solid #00ffff;
            border-radius: 15px;
            pointer-events: auto;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.6);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #00ffff;
            font-size: 2rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .interact-hint {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 10px;
            border: 1px solid #00ffff;
            color: #00ffff;
            font-weight: bold;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Showroom Y√ºkleniyor...</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
        <div class="controls-info">
            <h3>üéÆ Kontroller</h3>
            <p><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> - Hareket</p>
            <p><kbd>SPACE</kbd> - Zƒ±pla</p>
            <p><kbd>SHIFT</kbd> - Ko≈ü</p>
            <p><kbd>FARE</kbd> - Etrafƒ±na Bak</p>
            <p><kbd>E</kbd> - Etkile≈üim</p>
        </div>

        <div class="minimap" id="minimap"></div>

        <div class="crosshair"></div>

        <div class="interact-hint" id="interactHint">
            [E] Tu≈üuna Basarak ƒ∞ncele
        </div>

        <div class="info-panel">
            <h3>üè¢ Ho≈ü Geldiniz</h3>
            <p>Showroom'umuzda √∂zg√ºrce dola≈üabilir, √ºr√ºnlerimizi inceleyebilirsiniz. ƒ∞lgili objelere yakla≈üarak detaylƒ± bilgi alabilirsiniz.</p>
        </div>
    </div>

    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Add point lights for atmosphere
        const pointLight1 = new THREE.PointLight(0x00ffff, 1, 20);
        pointLight1.position.set(-10, 5, 0);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 20);
        pointLight2.position.set(10, 5, 0);
        scene.add(pointLight2);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a3e,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        function createWall(width, height, position, rotation) {
            const geometry = new THREE.BoxGeometry(width, height, 0.5);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x16213e,
                roughness: 0.7
            });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.copy(position);
            if (rotation) wall.rotation.y = rotation;
            wall.receiveShadow = true;
            wall.castShadow = true;
            scene.add(wall);
        }

        createWall(50, 8, new THREE.Vector3(0, 4, -25), 0);
        createWall(50, 8, new THREE.Vector3(0, 4, 25), 0);
        createWall(50, 8, new THREE.Vector3(-25, 4, 0), Math.PI / 2);
        createWall(50, 8, new THREE.Vector3(25, 4, 0), Math.PI / 2);

        // Display Pedestals with Products
        function createPedestal(position, color, label) {
            const pedestalGroup = new THREE.Group();

            // Base
            const baseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.3, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            pedestalGroup.add(base);

            // Column
            const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 32);
            const columnMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.position.y = 1;
            column.castShadow = true;
            pedestalGroup.add(column);

            // Top
            const topGeometry = new THREE.CylinderGeometry(1, 1, 0.3, 32);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 2.15;
            top.castShadow = true;
            pedestalGroup.add(top);

            // Product (rotating shape)
            const productGeometry = new THREE.OctahedronGeometry(0.6, 0);
            const productMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.8,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const product = new THREE.Mesh(productGeometry, productMaterial);
            product.position.y = 3;
            product.castShadow = true;
            product.userData = { label: label, interactive: true };
            pedestalGroup.add(product);

            // Rotate product
            function rotateProduct() {
                product.rotation.y += 0.01;
                product.rotation.x += 0.005;
                requestAnimationFrame(rotateProduct);
            }
            rotateProduct();

            pedestalGroup.position.copy(position);
            scene.add(pedestalGroup);

            return product;
        }

        const products = [];
        products.push(createPedestal(new THREE.Vector3(-10, 0, -10), 0x00ffff, "Cyber Kulaklƒ±k"));
        products.push(createPedestal(new THREE.Vector3(0, 0, -10), 0xff00ff, "Smart Watch Pro"));
        products.push(createPedestal(new THREE.Vector3(10, 0, -10), 0xffff00, "VR G√∂zl√ºk X"));
        products.push(createPedestal(new THREE.Vector3(-10, 0, 0), 0xff0080, "Gaming Mouse"));
        products.push(createPedestal(new THREE.Vector3(10, 0, 0), 0x00ff80, "Mechanical Keyboard"));

        // Movement Controls
        const keys = {};
        const moveSpeed = 0.1;
        const runMultiplier = 2;
        const jumpForce = 0.3;
        let velocity = new THREE.Vector3();
        let isJumping = false;

        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Mouse Look
        let mouseX = 0, mouseY = 0;
        let rotationX = 0, rotationY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = e.movementX || 0;
            mouseY = e.movementY || 0;
        });

        // Pointer Lock
        document.getElementById('canvas').addEventListener('click', () => {
            document.getElementById('canvas').requestPointerLock();
        });

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const interactHint = document.getElementById('interactHint');

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Camera rotation
            rotationY -= mouseX * 0.002;
            rotationX -= mouseY * 0.002;
            rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = rotationY;
            camera.rotation.x = rotationX;

            mouseX *= 0.9;
            mouseY *= 0.9;

            // Movement
            const direction = new THREE.Vector3();
            const speed = keys['shift'] ? moveSpeed * runMultiplier : moveSpeed;

            if (keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (keys['a']) direction.x -= 1;
            if (keys['d']) direction.x += 1;

            direction.normalize();
            direction.applyQuaternion(camera.quaternion);
            direction.y = 0;

            camera.position.add(direction.multiplyScalar(speed));

            // Jump
            if (keys[' '] && !isJumping && camera.position.y <= 1.6) {
                velocity.y = jumpForce;
                isJumping = true;
            }

            // Gravity
            velocity.y -= 0.01;
            camera.position.y += velocity.y;

            if (camera.position.y <= 1.6) {
                camera.position.y = 1.6;
                velocity.y = 0;
                isJumping = false;
            }

            // Boundaries
            camera.position.x = Math.max(-23, Math.min(23, camera.position.x));
            camera.position.z = Math.max(-23, Math.min(23, camera.position.z));

            // Interaction detection
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(products);

            if (intersects.length > 0 && intersects[0].distance < 5) {
                interactHint.style.display = 'block';
                if (keys['e']) {
                    alert(`√úr√ºn: ${intersects[0].object.userData.label}\n\n√ñzellikler: Premium kalite, son teknoloji\nFiyat: ‚Ç∫${Math.floor(Math.random() * 5000 + 1000).toLocaleString('tr-TR')}`);
                    keys['e'] = false;
                }
            } else {
                interactHint.style.display = 'none';
            }

            renderer.render(scene, camera);
        }

        // Loading
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 1500);

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>